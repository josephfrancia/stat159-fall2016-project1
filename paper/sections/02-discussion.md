&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So what's the big deal about reproducibility? To tackle this vague question, lets first answer another question: what does it mean for a paper's results to be reproducible? Reproducibility simply means that a third party (peer reviewer, fellow researcher, etc.) can reproduce a paper's results, using the computational methods described in the paper. As a result, it can mean a couple things if a paper's results fail to be reproducible.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For one, it could simply mean that a paper's results were not reproducible because of a simple coding/computational error (e.g. [Reinhart-Rogoff controversy](https://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt)). In this case, checking for reproducibiility in one's paper would help because the authors would have discovered a coding error when figuring out why their results were not reproducible.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Secondly, it could also mean that the paper's results were actually correct, but just not reproducible. How does this happen? Maybe the author's computations and results were all totally correct, but the author's paper was ambiguous or unclear about how certain computations were made. As a result, making this kind of paper reproducible would result in a paper that is much more clear and forthcoming about its computational methodology.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now that we have shown how a lack of reproducibility can be symptomatic of more serious flaws, lets talk about the software tools that help us keep our research reproducible. Lets first talk about **Git**. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![Git](https://raw.githubusercontent.com/ucb-stat159/stat159-fall-2016/master/projects/proj01/images/git-logo.png)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here's a quick definitional introduction to what **Git** is. **Git** is version-control software that allows us to keep track of changes that we have made in a file over time. It also allows a user to explore various versions of a file. Without **Git**, a user only has access to the most recently saved version of a file. With **Git**, however, a user can have access to previously committed versions of a file.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Why might this be useful? Lets look at an example. For instance, lets say that a user decides that some code he or she deleted awhile back might actually turn out to be useful for the next phase of the project. Without **Git**, this user would have to rewrite all this code that had already been written. However, if this user had used **Git**, this user would have access to all previous versions of the project, thus allowing the user to simply copy-paste some of the old code that had been deleted.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Another advantage to using **Git** has to do with reproducibility. **Git** essentially forces us to explicitly document the changes we’ve made to a file with relevant, detailed comments. Thus, if months after a project we decide that we want to try to reproduce the results of our project, we can look at the previous versions and the associated comments in order to make sense of what exactly it is that we did (The command “git log” allows us to take a look at all the previous versions of our file and all of the associated comments).  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; While **Git** is useful for tracking changes in our personal projects or code, it is not sufficient for tracking changes in group projects. For that task, **Github** is a nice tool that accompanies **Git**. 

![Github](https://raw.githubusercontent.com/ucb-stat159/stat159-fall-2016/master/projects/proj01/images/github-logo.png)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It’s important to highlight the differences between **GitHub** and **Git** because from my experience, people often conflate the two. **GitHub** is essentially an extension of **Git**. While **Git** allows a single user to track changes on a file, **GitHub** is an online repository that allows multiple users to track each other’s changes on the same file.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Github** is an online repository that allows its users to store their **Git** repositories online. By allowing people to share repositories, **Github** helps people collaborate on a project with greater ease. For instance, one can have multiple branches for a single project on **Github**, thus allowing project partners to work separately on certain branches while collaborating on others. Moreover, **Github** allows project partners to see what changes or contributions that their partners have made to files on certain branches.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For this paper, I used both **Git** and **Github**. While I may not have needed to use **Github** because I was not working with a group, I found it good practice, learning how to use basic git commands. In lab, I was running into issues with **Git** where I kept getting the error "*permission denied (publickey)*". As a result, I used a nice [Github article](https://help.github.com/articles/error-permission-denied-publickey/) that helped me debug this issue (I just had to setup an SSH key). Other than this bug, I had no other issues using **Git** for this project. In the next section of this paper, I am going to be talking about another tool that helps us make our projects reproducible: **Makefiles**.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So what's a **Makefile**? A **Makefile** is a special file that, along with the tool **Make**, allows us to run shell commands with ease. Running the **Makefile** on your terminal will cause all commands in the **Makefile** to be run. **Makefiles** are important for quite a few reasons. For one, they can save us quite a bit of time. Instead of having to type out a bunch of shell commands (and potentially forgetting which shell commands to type), running the **Makefile** will run all of the shell commands at once. When navigating through various datasets and files one is using for a large project, we can potentially save a lot of time using a **Makefile**. More importantly, however, using **Makefiles** makes reproducing one’s code much easier.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Up until this class, I have never had any experience with **Makefiles** before. In addition, I have never had experience with a language that needed to be compiled before, so I did not quite understand why **Makefiles** could be so useful. To be honest, this was the most challenging part of the project for me. As a result, I had to refer frequently back to [Lab 4](http://www.cirosantilli.com/markdown-style-guide/) in order to refresh my understanding of the basics of **Makefiles**. I found Lab 4 super helpful because it was very example-oriented. In other words, I was able to very easily follow along with the sample code and terminal commands that were provided. Eventually, I was able to create a **Makefile** that used **Pandoc** to convert this paper from a **Markdown** format to an **HTML** format.  Speaking of **Pandoc**, lets transition over to my next section. 

![Pandoc](https://raw.githubusercontent.com/ucb-stat159/stat159-fall-2016/master/projects/proj01/images/pandoc-logo.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **Pandoc** is a universal document converter. It allows us to convert a document from one type of format into another. For instance, if one wants to convert a **Markdown** file into an **HTML** file, one can use the following terminal command:    
```pandoc -s document.md -o document.html```  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While it is pretty neat that we can convert a document into different formats from the **Terminal**, are these **Pandoc** commands any better than traditional ways of converting a file?  After all, one can just save a **Markdown** file as an **HTML** by clicking “Save As.” The advantage of using **Pandoc** commands is that we can write these **Pandoc** commands into a **Makefile**, thus allowing us to automate and document our file conversion process. Instead of having to manually open a bunch of files and clicking “Save As,” we can instead write our commands to a **Makefile** and then convert them all at once with a one-word command in the **Terminal**:  
```make```  
In the next section, we are going to discuss one of the file types that Pandoc works with: **Markdown**.  
![Markdown](https://raw.githubusercontent.com/ucb-stat159/stat159-fall-2016/master/projects/proj01/images/markdown-logo.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **Markdown** is an alternative to Word and plain text editors, and it allows us to format our essays or reports with ease. As the [Github website](https://guides.github.com/features/mastering-markdown/) succinctly describes it, “Mostly Markdown is just regular text with a few non-alphabetical characters thrown in there like  `#` or `*`." In addition to their ease of use, **Markdown** files  also have the advantage of being easily convertible into HTML. This makes **Markdown** files very useful for writing articles or essays that will be posted on a blog or website.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As someone who has always used Google Docs or Microsoft Word, it was a whole new experience using **Markdown** files. In **Markdown**, I found myself formatting syntax by typing, rather than pointing and clicking. Although I initially had to refer the [Markdown cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#code) quite often, I quickly got the gist of the syntax, and I found that formatting in **Markdown** was actually faster than in Google Docs or Microsoft Word. For me, learning how to use **Markdown** files was actually the easiest part of the project. Sure, I had to learn a new syntax, but it was often quite intuitive. And when syntax wasn't super intuitive (I had syntax issues embedding images into my **Markdown** file), I just referred to the resources that Professor Sanchez provided. 


